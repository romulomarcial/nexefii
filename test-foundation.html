<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NEXEFII Foundation Test Suite</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1A1A1A;
      color: #E0E0E0;
      padding: 2rem;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    h1 {
      color: #E42121;
      margin-bottom: 0.5rem;
      font-size: 2.5rem;
    }

    .subtitle {
      color: #999;
      margin-bottom: 2rem;
      font-size: 1.125rem;
    }

    .controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    button {
      padding: 0.75rem 1.5rem;
      background: #E42121;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: background 0.2s;
    }

    button:hover {
      background: #C41A1A;
    }

    button:disabled {
      background: #555;
      cursor: not-allowed;
    }

    button.secondary {
      background: #333;
    }

    button.secondary:hover {
      background: #444;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1.5rem;
    }

    .stat-value {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .stat-value.success { color: #28A745; }
    .stat-value.error { color: #DC3545; }
    .stat-value.warning { color: #FFC107; }
    .stat-value.info { color: #17A2B8; }

    .stat-label {
      color: #999;
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .test-section {
      background: #252525;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      padding-bottom: 1rem;
      border-bottom: 1px solid #333;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #E42121;
    }

    .section-status {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .status-pending { background: #555; color: #CCC; }
    .status-running { background: #17A2B8; color: white; }
    .status-pass { background: #28A745; color: white; }
    .status-fail { background: #DC3545; color: white; }

    .test-results {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .test-result {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #1A1A1A;
      border-radius: 6px;
      border-left: 4px solid transparent;
    }

    .test-result.pass {
      border-left-color: #28A745;
    }

    .test-result.fail {
      border-left-color: #DC3545;
    }

    .test-name {
      font-weight: 500;
    }

    .test-details {
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 0.875rem;
    }

    .test-icon {
      font-size: 1.25rem;
    }

    .test-time {
      color: #999;
    }

    .test-error {
      margin-top: 0.5rem;
      padding: 0.75rem;
      background: #3A0000;
      border-left: 3px solid #DC3545;
      border-radius: 4px;
      font-size: 0.875rem;
      color: #FFB3B3;
      font-family: 'Courier New', monospace;
    }

    .log-container {
      background: #1A1A1A;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 1rem;
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
    }

    .log-entry {
      padding: 0.25rem 0;
      border-bottom: 1px solid #252525;
    }

    .log-entry:last-child {
      border-bottom: none;
    }

    .log-time {
      color: #666;
      margin-right: 0.5rem;
    }

    .log-level {
      padding: 0.125rem 0.5rem;
      border-radius: 3px;
      font-weight: 600;
      margin-right: 0.5rem;
    }

    .log-level.info { background: #17A2B8; color: white; }
    .log-level.success { background: #28A745; color: white; }
    .log-level.error { background: #DC3545; color: white; }
    .log-level.warn { background: #FFC107; color: black; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .running {
      animation: pulse 1.5s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß™ NEXEFII Foundation Test Suite</h1>
    <p class="subtitle">Valida√ß√£o completa da Foundation: PropertyDatabase + Router + Shell + Multi-tenant Isolation</p>

    <div class="controls">
      <button onclick="runAllTests()" id="run-all-btn">‚ñ∂Ô∏è Executar Todos os Testes</button>
      <button onclick="clearStorage()" class="secondary">üóëÔ∏è Limpar Storage</button>
      <button onclick="clearResults()" class="secondary">ÔøΩ Limpar Resultados</button>
      <button onclick="toggleLog()" class="secondary">üìã Toggle Log</button>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-value info" id="total-tests">0</div>
        <div class="stat-label">Total de Testes</div>
      </div>
      <div class="stat-card">
        <div class="stat-value success" id="passed-tests">0</div>
        <div class="stat-label">Testes Aprovados</div>
      </div>
      <div class="stat-card">
        <div class="stat-value error" id="failed-tests">0</div>
        <div class="stat-label">Testes Falhados</div>
      </div>
      <div class="stat-card">
        <div class="stat-value warning" id="duration">0ms</div>
        <div class="stat-label">Dura√ß√£o Total</div>
      </div>
    </div>

    <!-- Test Sections -->
    <div class="test-section">
      <div class="section-header">
        <h2 class="section-title">1. PropertyDatabase Isolation</h2>
        <span class="section-status status-pending" id="status-db">Pendente</span>
      </div>
      <div class="test-results" id="results-db"></div>
    </div>

    <div class="test-section">
      <div class="section-header">
        <h2 class="section-title">2. Router Integration</h2>
        <span class="section-status status-pending" id="status-router">Pendente</span>
      </div>
      <div class="test-results" id="results-router"></div>
    </div>

    <div class="test-section">
      <div class="section-header">
        <h2 class="section-title">3. Shell & Context Management</h2>
        <span class="section-status status-pending" id="status-shell">Pendente</span>
      </div>
      <div class="test-results" id="results-shell"></div>
    </div>

    <div class="test-section">
      <div class="section-header">
        <h2 class="section-title">4. Multi-Tenant Data Isolation</h2>
        <span class="section-status status-pending" id="status-isolation">Pendente</span>
      </div>
      <div class="test-results" id="results-isolation"></div>
    </div>

    <div class="test-section">
      <div class="section-header">
        <h2 class="section-title">5. Performance Benchmarks</h2>
        <span class="section-status status-pending" id="status-performance">Pendente</span>
      </div>
      <div class="test-results" id="results-performance"></div>
    </div>

    <!-- Debug Log -->
    <div class="test-section" id="log-section" style="display: none;">
      <div class="section-header">
        <h2 class="section-title">üìã Debug Log</h2>
      </div>
      <div class="log-container" id="log-container"></div>
    </div>
  </div>

  <!-- Core Scripts -->
  <script src="core/database/PropertyDatabase.js"></script>
  <script src="core/router/Router.js"></script>

  <script>
    // ============================================================================
    // Initialize NEXEFII Global (for standalone testing)
    // ============================================================================

    if (typeof window.NEXEFII === 'undefined') {
      window.NEXEFII = {
        router: null,
        currentProperty: null,
        currentDB: null,
        currentUser: null,
        pageModules: new Map()
      };
    }

    // ============================================================================
    // Test Framework
    // ============================================================================

    let stats = {
      total: 0,
      passed: 0,
      failed: 0,
      startTime: 0,
      endTime: 0
    };

    const logs = [];

    function log(level, message) {
      const timestamp = new Date().toLocaleTimeString();
      logs.push({ timestamp, level, message });
      
      const logContainer = document.getElementById('log-container');
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `
        <span class="log-time">${timestamp}</span>
        <span class="log-level ${level}">${level.toUpperCase()}</span>
        <span>${message}</span>
      `;
      logContainer.appendChild(entry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function toggleLog() {
      const logSection = document.getElementById('log-section');
      logSection.style.display = logSection.style.display === 'none' ? 'block' : 'none';
    }

    function updateStats() {
      document.getElementById('total-tests').textContent = stats.total;
      document.getElementById('passed-tests').textContent = stats.passed;
      document.getElementById('failed-tests').textContent = stats.failed;
      document.getElementById('duration').textContent = `${stats.endTime - stats.startTime}ms`;
    }

    function updateSectionStatus(section, status) {
      const statusEl = document.getElementById(`status-${section}`);
      statusEl.className = `section-status status-${status}`;
      statusEl.textContent = status === 'pass' ? 'Aprovado' : 
                             status === 'fail' ? 'Falhado' :
                             status === 'running' ? 'Executando...' : 'Pendente';
    }

    function addTestResult(section, testName, passed, duration, error = null) {
      stats.total++;
      if (passed) {
        stats.passed++;
      } else {
        stats.failed++;
      }

      const resultsContainer = document.getElementById(`results-${section}`);
      const resultDiv = document.createElement('div');
      resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;
      
      resultDiv.innerHTML = `
        <div class="test-name">
          <span class="test-icon">${passed ? '‚úÖ' : '‚ùå'}</span>
          ${testName}
        </div>
        <div class="test-details">
          <span class="test-time">${duration.toFixed(2)}ms</span>
        </div>
      `;

      if (error) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'test-error';
        errorDiv.textContent = error;
        resultDiv.appendChild(errorDiv);
      }

      resultsContainer.appendChild(resultDiv);
      updateStats();
    }

    async function runTest(section, testName, testFn) {
      const startTime = performance.now();
      try {
        await testFn();
        const duration = performance.now() - startTime;
        addTestResult(section, testName, true, duration);
        log('success', `‚úÖ ${testName} - ${duration.toFixed(2)}ms`);
        return true;
      } catch (error) {
        const duration = performance.now() - startTime;
        addTestResult(section, testName, false, duration, error.message);
        log('error', `‚ùå ${testName} - ${error.message}`);
        return false;
      }
    }

    function clearResults() {
      stats = { total: 0, passed: 0, failed: 0, startTime: 0, endTime: 0 };
      
      ['db', 'router', 'shell', 'isolation', 'performance'].forEach(section => {
        document.getElementById(`results-${section}`).innerHTML = '';
        updateSectionStatus(section, 'pending');
      });
      
      document.getElementById('log-container').innerHTML = '';
      logs.length = 0;
      updateStats();
    }

    function clearStorage() {
      // Clear all localStorage data for clean test environment
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('property_')) {
          keysToRemove.push(key);
        }
      }
      
      keysToRemove.forEach(key => localStorage.removeItem(key));
      
      log('success', `‚úÖ Cleared ${keysToRemove.length} storage keys`);
      alert(`Storage limpo! ${keysToRemove.length} chaves removidas.\n\nAgora execute os testes.`);
    }

    // ============================================================================
    // Test Suite
    // ============================================================================

    async function runAllTests() {
      log('info', 'üöÄ Starting Foundation Test Suite');
      stats.startTime = performance.now();
      
      document.getElementById('run-all-btn').disabled = true;

      // Test 1: PropertyDatabase Isolation
      await testPropertyDatabaseIsolation();

      // Test 2: Router Integration
      await testRouterIntegration();

      // Test 3: Shell & Context
      await testShellContext();

      // Test 4: Multi-Tenant Isolation
      await testMultiTenantIsolation();

      // Test 5: Performance
      await testPerformance();

      stats.endTime = performance.now();
      updateStats();
      
      document.getElementById('run-all-btn').disabled = false;

      const passRate = ((stats.passed / stats.total) * 100).toFixed(1);
      log('info', `üèÅ Tests Complete: ${stats.passed}/${stats.total} passed (${passRate}%)`);
      
      if (stats.failed === 0) {
        log('success', 'üéâ ALL TESTS PASSED!');
      } else {
        log('error', `‚ö†Ô∏è ${stats.failed} test(s) failed`);
      }
    }

    // ============================================================================
    // Test 1: PropertyDatabase Isolation
    // ============================================================================

    async function testPropertyDatabaseIsolation() {
      log('info', 'üì¶ Testing PropertyDatabase Isolation...');
      updateSectionStatus('db', 'running');

      // Clean previous test data
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('property_hotel-demo_') || key.startsWith('property_resort-paradise_'))) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      log('info', `üßπ Cleaned ${keysToRemove.length} residual keys`);

      let allPassed = true;

      // Test 1.1: Create two isolated databases
      allPassed &= await runTest('db', 'Create isolated PropertyDatabase instances', async () => {
        const db1 = new PropertyDatabase('hotel-demo');
        const db2 = new PropertyDatabase('resort-paradise');
        
        if (!db1 || !db2) throw new Error('Failed to create database instances');
        if (db1.propertyKey === db2.propertyKey) throw new Error('Databases share same key');
      });

      // Test 1.2: Write data to DB1
      allPassed &= await runTest('db', 'Write data to Property 1 (hotel-demo)', async () => {
        const db1 = new PropertyDatabase('hotel-demo');
        await db1.set('rooms', 'room-101', { number: 101, type: 'Standard', price: 150 });
        await db1.set('rooms', 'room-102', { number: 102, type: 'Deluxe', price: 250 });
        
        const rooms = await db1.getAll('rooms');
        if (rooms.length !== 2) throw new Error(`Expected 2 rooms, got ${rooms.length}`);
      });

      // Test 1.3: Verify DB2 is empty
      allPassed &= await runTest('db', 'Verify Property 2 (resort-paradise) is isolated', async () => {
        const db2 = new PropertyDatabase('resort-paradise');
        const rooms = await db2.getAll('rooms');
        
        if (rooms.length !== 0) throw new Error(`Expected 0 rooms in DB2, got ${rooms.length}`);
      });

      // Test 1.4: Write different data to DB2
      allPassed &= await runTest('db', 'Write data to Property 2 (resort-paradise)', async () => {
        const db2 = new PropertyDatabase('resort-paradise');
        await db2.set('rooms', 'room-201', { number: 201, type: 'Suite', price: 500 });
        
        const rooms = await db2.getAll('rooms');
        if (rooms.length !== 1) throw new Error(`Expected 1 room, got ${rooms.length}`);
      });

      // Test 1.5: Verify DB1 still has original data
      allPassed &= await runTest('db', 'Verify Property 1 data unchanged', async () => {
        const db1 = new PropertyDatabase('hotel-demo');
        const rooms = await db1.getAll('rooms');
        
        if (rooms.length !== 2) throw new Error(`Expected 2 rooms, got ${rooms.length}`);
        if (rooms[0].number !== 101 && rooms[1].number !== 101) {
          throw new Error('Original room 101 not found');
        }
      });

      // Test 1.6: Cross-contamination check
      allPassed &= await runTest('db', 'Cross-contamination check (room-201 not in DB1)', async () => {
        const db1 = new PropertyDatabase('hotel-demo');
        const room201 = await db1.get('rooms', 'room-201');
        
        if (room201 !== null) throw new Error('Room 201 leaked from DB2 to DB1!');
      });

      updateSectionStatus('db', allPassed ? 'pass' : 'fail');
    }

    // ============================================================================
    // Test 2: Router Integration
    // ============================================================================

    async function testRouterIntegration() {
      log('info', 'üß≠ Testing Router Integration...');
      updateSectionStatus('router', 'running');

      let allPassed = true;

      // Test 2.1: Router creates correctly
      allPassed &= await runTest('router', 'Create Router instance', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        if (!router) throw new Error('Failed to create router');
      });

      // Test 2.2: Property resolver works
      allPassed &= await runTest('router', 'Property resolver integration', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        
        const mockProperties = [
          { id: 1, slug: 'hotel-demo', name: 'Hotel Demo' },
          { id: 2, slug: 'resort-paradise', name: 'Resort Paradise' }
        ];
        
        router.setPropertyResolver(async (slug) => {
          return mockProperties.find(p => p.slug === slug) || null;
        });
        
        const property = await router.propertyResolver('hotel-demo');
        if (!property) throw new Error('Property resolver failed');
        if (property.name !== 'Hotel Demo') throw new Error('Wrong property resolved');
      });

      // Test 2.3: Route registration
      allPassed &= await runTest('router', 'Register routes', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        
        router.route('/property/:slug/dashboard', async (ctx) => {});
        router.route('/property/:slug/settings', async (ctx) => {});
        
        if (router.routes.length !== 2) throw new Error('Routes not registered');
      });

      // Test 2.4: Auth guard
      allPassed &= await runTest('router', 'Auth guard blocks unauthenticated', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        let guardCalled = false;
        
        router.setAuthGuard(async () => {
          guardCalled = true;
          return false; // Block access
        });
        
        router.route('/test', async () => {
          throw new Error('Route handler should not run');
        });
        
        await router._handleRoute('/test');
        
        if (!guardCalled) throw new Error('Auth guard not called');
      });

      // Test 2.5: Property access guard
      allPassed &= await runTest('router', 'Property access guard', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        
        router.setPropertyResolver(async () => ({ id: 1, name: 'Hotel Demo' }));
        router.setAuthGuard(async () => true);
        
        let accessGranted = false;
        router.setPropertyAccessGuard(async (property) => {
          accessGranted = property.id === 1;
          return accessGranted;
        });
        
        router.route('/property/:slug/test', async () => {});
        await router._handleRoute('/property/hotel-demo/test');
        
        if (!accessGranted) throw new Error('Property access guard not working');
      });

      updateSectionStatus('router', allPassed ? 'pass' : 'fail');
    }

    // ============================================================================
    // Test 3: Shell & Context Management
    // ============================================================================

    async function testShellContext() {
      log('info', 'üêö Testing Shell & Context Management...');
      updateSectionStatus('shell', 'running');

      let allPassed = true;

      // Test 3.1: Global NEXEFII object exists
      allPassed &= await runTest('shell', 'Global NEXEFII object available', async () => {
        if (typeof window.NEXEFII === 'undefined') {
          throw new Error('window.NEXEFII not defined');
        }
      });

      // Test 3.2: Session management
      allPassed &= await runTest('shell', 'Session storage works', async () => {
        const testUser = {
          id: 999,
          email: 'test@nexefii.com',
          name: 'Test User',
          properties: []
        };
        
        localStorage.setItem('nexefii_session', JSON.stringify(testUser));
        const retrieved = JSON.parse(localStorage.getItem('nexefii_session'));
        
        if (retrieved.email !== 'test@nexefii.com') {
          throw new Error('Session not persisted correctly');
        }
        
        localStorage.removeItem('nexefii_session');
      });

      // Test 3.3: Context switching
      allPassed &= await runTest('shell', 'Property context switching', async () => {
        const prop1 = { id: 1, key: 'hotel-demo', name: 'Hotel Demo' };
        const prop2 = { id: 2, key: 'resort-paradise', name: 'Resort Paradise' };
        
        // Simulate context switch
        window.NEXEFII.currentProperty = prop1;
        window.NEXEFII.currentDB = new PropertyDatabase(prop1.key);
        
        if (window.NEXEFII.currentProperty.id !== 1) {
          throw new Error('Context not set correctly');
        }
        
        // Switch to prop2
        window.NEXEFII.currentProperty = prop2;
        window.NEXEFII.currentDB = new PropertyDatabase(prop2.key);
        
        if (window.NEXEFII.currentProperty.id !== 2) {
          throw new Error('Context switch failed');
        }
      });

      updateSectionStatus('shell', allPassed ? 'pass' : 'fail');
    }

    // ============================================================================
    // Test 4: Multi-Tenant Data Isolation (End-to-End)
    // ============================================================================

    async function testMultiTenantIsolation() {
      log('info', 'üè® Testing Multi-Tenant Data Isolation (E2E)...');
      updateSectionStatus('isolation', 'running');

      // Clean previous test data
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('property_hotel-demo_') || key.startsWith('property_resort-paradise_'))) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      log('info', `üßπ Cleaned ${keysToRemove.length} residual keys for multi-tenant test`);

      let allPassed = true;

      // Test 4.1: Full isolation test
      allPassed &= await runTest('isolation', 'Complete data isolation between properties', async () => {
        // Property 1
        const db1 = new PropertyDatabase('hotel-demo');
        await db1.set('guests', 'guest-1', { name: 'John Doe', email: 'john@hotel-demo.com' });
        await db1.set('reservations', 'res-1', { guestId: 'guest-1', roomNumber: 101 });
        
        // Property 2
        const db2 = new PropertyDatabase('resort-paradise');
        await db2.set('guests', 'guest-1', { name: 'Jane Smith', email: 'jane@resort.com' });
        await db2.set('reservations', 'res-1', { guestId: 'guest-1', roomNumber: 201 });
        
        // Verify isolation
        const hotel1Guest = await db1.get('guests', 'guest-1');
        const resort2Guest = await db2.get('guests', 'guest-1');
        
        if (hotel1Guest.name === resort2Guest.name) {
          throw new Error('Guest data leaked between properties!');
        }
        
        if (hotel1Guest.email !== 'john@hotel-demo.com') {
          throw new Error('Hotel guest data corrupted');
        }
        
        if (resort2Guest.email !== 'jane@resort.com') {
          throw new Error('Resort guest data corrupted');
        }
      });

      // Test 4.2: Metadata isolation
      allPassed &= await runTest('isolation', 'Metadata isolation (_propertyId, _createdAt)', async () => {
        const db1 = new PropertyDatabase('hotel-demo');
        const db2 = new PropertyDatabase('resort-paradise');
        
        await db1.set('test', 'item-1', { value: 'A' });
        await db2.set('test', 'item-1', { value: 'B' });
        
        const item1 = await db1.get('test', 'item-1');
        const item2 = await db2.get('test', 'item-1');
        
        if (item1._propertyId === item2._propertyId) {
          throw new Error('Metadata propertyId not isolated');
        }
        
        if (item1._propertyId !== 'hotel-demo') {
          throw new Error('Wrong propertyId in DB1');
        }
        
        if (item2._propertyId !== 'resort-paradise') {
          throw new Error('Wrong propertyId in DB2');
        }
      });

      // Test 4.3: Collection isolation
      allPassed &= await runTest('isolation', 'Collection count isolation', async () => {
        // Use unique collection name to avoid conflicts with previous test runs
        const collectionName = `test_${Date.now()}`;
        
        const db1 = new PropertyDatabase('hotel-demo');
        const db2 = new PropertyDatabase('resort-paradise');
        
        // Add different amounts to UNIQUE collection
        await db1.set(collectionName, 'a', { value: 1 });
        await db1.set(collectionName, 'b', { value: 2 });
        await db1.set(collectionName, 'c', { value: 3 });
        
        await db2.set(collectionName, 'd', { value: 4 });
        
        const count1 = (await db1.getAll(collectionName)).length;
        const count2 = (await db2.getAll(collectionName)).length;
        
        if (count1 !== 3) throw new Error(`Expected 3 items in DB1, got ${count1}`);
        if (count2 !== 1) throw new Error(`Expected 1 item in DB2, got ${count2}`);
        
        // Cleanup
        await db1.delete(collectionName, 'a');
        await db1.delete(collectionName, 'b');
        await db1.delete(collectionName, 'c');
        await db2.delete(collectionName, 'd');
      });

      updateSectionStatus('isolation', allPassed ? 'pass' : 'fail');
    }

    // ============================================================================
    // Test 5: Performance Benchmarks
    // ============================================================================

    async function testPerformance() {
      log('info', '‚ö° Running Performance Benchmarks...');
      updateSectionStatus('performance', 'running');

      let allPassed = true;

      // Test 5.1: Database SET performance
      allPassed &= await runTest('performance', 'PropertyDatabase SET operation < 1ms', async () => {
        const db = new PropertyDatabase('perf-test');
        const iterations = 100;
        
        const start = performance.now();
        for (let i = 0; i < iterations; i++) {
          await db.set('perf', `item-${i}`, { value: i });
        }
        const duration = performance.now() - start;
        const avgTime = duration / iterations;
        
        log('info', `SET avg: ${avgTime.toFixed(3)}ms per operation`);
        
        if (avgTime > 1) throw new Error(`SET too slow: ${avgTime.toFixed(2)}ms > 1ms`);
      });

      // Test 5.2: Database GET performance
      allPassed &= await runTest('performance', 'PropertyDatabase GET operation < 0.1ms', async () => {
        const db = new PropertyDatabase('perf-test');
        await db.set('perf', 'test-item', { value: 123 });
        
        const iterations = 100;
        const start = performance.now();
        for (let i = 0; i < iterations; i++) {
          await db.get('perf', 'test-item');
        }
        const duration = performance.now() - start;
        const avgTime = duration / iterations;
        
        log('info', `GET avg: ${avgTime.toFixed(3)}ms per operation`);
        
        if (avgTime > 0.1) throw new Error(`GET too slow: ${avgTime.toFixed(2)}ms > 0.1ms`);
      });

      // Test 5.3: Router navigation performance
      allPassed &= await runTest('performance', 'Router navigation < 50ms', async () => {
        const router = Router.create({ mode: 'hash', debug: false });
        router.setAuthGuard(async () => true);
        router.setPropertyResolver(async (slug) => ({ id: 1, slug, name: 'Test' }));
        
        let handlerCalled = false;
        router.route('/property/:slug/dashboard', async () => {
          handlerCalled = true;
        });
        
        const start = performance.now();
        await router._handleRoute('/property/test-hotel/dashboard');
        const duration = performance.now() - start;
        
        log('info', `Router navigation: ${duration.toFixed(2)}ms`);
        
        if (!handlerCalled) throw new Error('Route handler not called');
        if (duration > 50) throw new Error(`Navigation too slow: ${duration.toFixed(2)}ms > 50ms`);
      });

      // Test 5.4: Context switch performance
      allPassed &= await runTest('performance', 'Context switch < 10ms', async () => {
        const prop1 = { id: 1, key: 'hotel-1', name: 'Hotel 1' };
        const prop2 = { id: 2, key: 'hotel-2', name: 'Hotel 2' };
        
        const start = performance.now();
        window.NEXEFII.currentProperty = prop1;
        window.NEXEFII.currentDB = new PropertyDatabase(prop1.key);
        
        window.NEXEFII.currentProperty = prop2;
        window.NEXEFII.currentDB = new PropertyDatabase(prop2.key);
        const duration = performance.now() - start;
        
        log('info', `Context switch: ${duration.toFixed(2)}ms`);
        
        if (duration > 10) throw new Error(`Context switch too slow: ${duration.toFixed(2)}ms > 10ms`);
      });

      updateSectionStatus('performance', allPassed ? 'pass' : 'fail');
    }
  </script>
</body>
</html>
