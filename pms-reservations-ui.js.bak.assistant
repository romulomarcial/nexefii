// PMS Reservations UI Controller
// Handles rendering, interaction, and state management for reservations interface

// Utility: Render PMS module switcher dynamically for i18n/scale
function renderPMSModuleSwitcher(modules, current, i18nDict) {
  const sel = document.getElementById('pmsModuleSwitcher');
  if (!sel) return;
  console.info('[renderPMSModuleSwitcher] Chamado. modules:', modules, 'current:', current, 'i18nDict:', i18nDict);
  sel.innerHTML = '';
  modules.forEach(mod => {
    const opt = document.createElement('option');
    opt.value = mod.value;
    opt.selected = mod.value === current;
    // Emoji + label from i18n
    opt.textContent = `${mod.emoji} ${(i18nDict[mod.i18nKey] || mod.fallback)}`;
    sel.appendChild(opt);
  });
}

class ReservationsUIController {
  constructor() {
    this.currentProperty = 'property_default'; // TODO: Get from session/context
    this.reservationEngine = window.getReservationEngine(this.currentProperty);
    this.groupManager = window.getGroupManager(this.currentProperty);
    this.channelManager = window.getChannelManager(this.currentProperty);
    this.ratePlan = new window.RatePlanEngine();
    
    this.currentView = 'list';
    this.currentFilter = 'all';
    this.searchQuery = '';
    this.filters = {
      dateFrom: null,
      dateTo: null,
      status: '',
      roomType: '',
      source: ''
    };

  // Language comes from central i18n manager if available
  this.currentLang = (window.NEXEFII && window.NEXEFII.i18n ? window.NEXEFII.i18n.getLanguage() : (localStorage.getItem('ilux_lang') || 'pt'));
  this.translations = {};

    this.init();
  }

  async init() {
    console.log('[Reservations] Initializing...');
    console.log('[Reservations] Current language:', this.currentLang);
    
    try {
      await this.loadTranslations();
      // If central i18n has the reservations segment, merge it for consistency
      try {
        if (window.NEXEFII && window.NEXEFII.i18n) {
          const seg = window.NEXEFII.i18n.translations?.[this.currentLang];
            if (seg) {
              ['resPageTitle','resFilters','resDateFrom','resDateTo','resStatus','resAllStatuses','resConfirmed','resPending','resCheckedIn','resCheckedOut','resCancelled','resRoomType','resAllRooms','resStandard','resDeluxe','resSuite','resSource','resAllChannels','resDirect','resOTA','resPhone','resWalkIn','resNewReservation','resExport','resNoResults','resNoResultsDesc','resNights','resNightsPlural'].forEach(k=>{
                if (seg[k] && !this.translations[k]) this.translations[k] = seg[k];
              });
            }
        }
      } catch(e) { console.warn('[Reservations] merge with central i18n failed', e); }
      console.log('[Reservations] Translations loaded successfully');
    } catch (e) {
      console.error('[Reservations] Failed to load translations:', e);
    }

    // Render module switcher dynamically for i18n/scale
    const mods = [
      { value: 'pms-reservations.html', i18nKey: 'resPageTitle', emoji: 'üìÖ', fallback: 'Reservas' },
      { value: 'pms-frontdesk.html', i18nKey: 'fdTitle', emoji: 'üîë', fallback: 'Check-in / Check-out' },
      { value: 'pms-rooms.html', i18nKey: 'rmPageTitle', emoji: 'üõèÔ∏è', fallback: 'Gest√£o de Quartos' }
    ];
    try {
      const session = window.IluxAuth && IluxAuth.getCurrentSession ? IluxAuth.getCurrentSession() : null;
      if (session && session.role === 'master') {
        mods.unshift({ value: 'master-control.html', i18nKey: 'masterControl', emoji: 'üîê', fallback: 'Master Control' });
      }
    } catch(e){}
    renderPMSModuleSwitcher(mods, 'pms-reservations.html', this.translations);

    this.applyTranslations();
    this.setupEventListeners();
    console.log('[Reservations] Event listeners setup complete');
    
    this.renderStats();
    this.renderReservations();
    this.updateAvailability();
    
    console.log('[Reservations] Initialization complete');
    
    // Auto-refresh every 30 seconds
    setInterval(() => this.refreshData(), 30000);
  }

  async loadTranslations() {
    // Prefer modular segment file: /i18n/{lang}/reservations.json
    try {
      const url = `/i18n/${this.currentLang}/reservations.json`;
      const resp = await fetch(url, { cache: 'no-store' });
      if (resp.ok) {
        this.translations = await resp.json();
        console.log('[Reservations] Loaded modular segment', this.currentLang, Object.keys(this.translations).length, 'keys');
        return;
      }
      console.warn('[Reservations] Segment not found, falling back to legacy fetch');
    } catch (e) {
      console.warn('[Reservations] Segment fetch failed', e.message);
    }
    // Legacy fallback (monolithic) if segment not available
    try {
      const response = await fetch('i18n.json', { cache: 'no-store' });
      if (response.ok) {
        const data = await response.json();
        const legacy = data[this.currentLang]?.app || {};
        ['resFilters','resPageTitle','resNewReservation','resExport','resNoResults','resNoResultsDesc'].forEach(k=>{
          if (legacy[k]) this.translations[k] = legacy[k];
        });
        console.log('[Reservations] Legacy keys merged');
      }
    } catch(e) {
      console.warn('[Reservations] Legacy fallback failed', e.message);
    }
    // Minimum guaranteed fallback
    if (!this.translations.resPageTitle) {
      this.translations = Object.assign({
        resFilters: 'Filtros',
        resPageTitle: 'Reservas',
        resNewReservation: 'Nova Reserva',
        resExport: 'Exportar',
        resNoResults: 'Nenhuma reserva encontrada',
        resNoResultsDesc: 'Tente ajustar os filtros ou criar uma nova reserva.'
      }, this.translations);
    }
  }

  applyTranslations() {
    console.log('[Reservations] Applying translations...');
    let count = 0;
    
    // Apply translations to all elements with data-i18n attribute
    document.querySelectorAll('[data-i18n]').forEach(el => {
      const key = el.getAttribute('data-i18n');
      if (this.translations[key]) {
        el.textContent = this.translations[key];
        count++;
      } else {
        console.warn('[Reservations] Missing translation for key:', key);
      }
    });

    // Apply placeholder translations
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
      const key = el.getAttribute('data-i18n-placeholder');
      if (this.translations[key]) {
        el.placeholder = this.translations[key];
        count++;
      }
    });
    
    console.log('[Reservations] Applied', count, 'translations');
  }

  t(key) {
    return this.translations[key] || key;
  }

  setupEventListeners() {
    console.log('[Reservations] Setting up event listeners...');
    
    // View toggle
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target.closest('.view-toggle-btn');
        if (target) {
          const view = target.dataset.view;
          console.log('[Reservations] Switching to view:', view);
          this.switchView(view);
        }
      });
    });

    // Quick filters
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const filter = e.target.dataset.filter;
        console.log('[Reservations] Applying quick filter:', filter);
        this.applyQuickFilter(filter);
      });
    });

    // Search
    const searchInput = document.getElementById('searchReservations');
    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        this.searchQuery = e.target.value.toLowerCase();
        console.log('[Reservations] Search query:', this.searchQuery);
        this.renderReservations();
      });
    }

    // Filter form
    const btnApplyFilters = document.getElementById('btnApplyFilters');
    if (btnApplyFilters) {
      btnApplyFilters.addEventListener('click', () => {
        console.log('[Reservations] Applying filters...');
        this.applyFilters();
      });
    }

    // New reservation button
    const btnNewReservation = document.getElementById('btnNewReservation');
    if (btnNewReservation) {
      console.log('[Reservations] New reservation button found');
      btnNewReservation.addEventListener('click', (e) => {
        console.log('[Reservations] New reservation button clicked');
        e.preventDefault();
        e.stopPropagation();
        this.openNewReservationModal();
      });
    } else {
      console.error('[Reservations] New reservation button NOT found!');
    }

    // Export button
    const btnExport = document.getElementById('btnExport');
    if (btnExport) {
      btnExport.addEventListener('click', () => {
        console.log('[Reservations] Exporting reservations...');
        this.exportReservations();
      });
    }

    // New Reservation Modal
    this.setupNewReservationModal();
    
    console.log('[Reservations] Event listeners setup complete');
  }

  setupNewReservationModal() {
    console.log('[Reservations] Setting up new reservation modal...');
    
    const modal = document.getElementById('newReservationModal');
    if (!modal) {
      console.error('[Reservations] Modal element NOT found!');
      return;
    }
    console.log('[Reservations] Modal element found');
    
    const closeBtn = document.getElementById('closeNewResModal');
    const cancelBtn = document.getElementById('btnCancelNewRes');
    const form = document.getElementById('newReservationForm');

    // Close modal
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        console.log('[Reservations] Closing modal (X button)');
        modal.style.display = 'none';
      });
    }

    if (cancelBtn) {
      cancelBtn.addEventListener('click', () => {
        console.log('[Reservations] Closing modal (Cancel button)');
        modal.style.display = 'none';
      });
    }

    // Click outside to close
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        console.log('[Reservations] Closing modal (outside click)');
        modal.style.display = 'none';
      }
    });

    // Date change handlers - calculate nights and update rate
    const checkInDate = document.getElementById('checkInDate');
    const checkOutDate = document.getElementById('checkOutDate');
    const roomTypeId = document.getElementById('roomTypeId');
    const ratePlanId = document.getElementById('ratePlanId');
    const adults = document.getElementById('adults');

    [checkInDate, checkOutDate, roomTypeId, ratePlanId, adults].forEach(el => {
      if (el) {
        el.addEventListener('change', () => {
          console.log('[Reservations] Form field changed:', el.id);
          this.updateReservationCalculations();
        });
      }
    });

    // Check availability button
    const btnCheckAvail = document.getElementById('btnCheckAvailability');
    if (btnCheckAvail) {
      btnCheckAvail.addEventListener('click', () => {
        console.log('[Reservations] Checking availability...');
        this.checkAvailabilityForNewRes();
      });
    }

    // Form submission (handles new vs edit)
    if (form) {
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        console.log('[Reservations] Form submitted');
        this.handleReservationSubmit();
      });
    }
    
    console.log('[Reservations] Modal setup complete');
  }

  loadI18n() {
    // Translations are now loaded in init()
  }

  switchView(view) {
    console.log('[Reservations] Switching view to:', view);
    this.currentView = view;

    // Update active button
    document.querySelectorAll('.view-toggle-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.view === view);
    });

    // Show/hide views
    const listView = document.getElementById('reservationListView');
    const calendarView = document.getElementById('reservationCalendarView');
    
    if (listView) listView.style.display = view === 'list' ? 'block' : 'none';
    if (calendarView) calendarView.style.display = (view === 'calendar' || view === 'timeline') ? 'block' : 'none';

    if (view === 'list') {
      this.renderReservations();
    } else if (view === 'calendar') {
      this.renderCalendar();
    } else if (view === 'timeline') {
      this.renderTimeline();
    }
  }

  applyQuickFilter(filter) {
    this.currentFilter = filter;

    // Update active button
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.filter === filter);
    });

    // Set date filters based on quick filter
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    switch (filter) {
      case 'in-house':
        // Show only guests currently in the hotel (checked-in)
        this.filters.status = 'checked_in';
        this.filters.dateFrom = null;
        this.filters.dateTo = null;
        break;
      case 'today':
        this.filters.dateFrom = this.formatDate(today);
        this.filters.dateTo = this.formatDate(today);
        this.filters.status = '';
        break;
      case 'tomorrow':
        this.filters.dateFrom = this.formatDate(tomorrow);
        this.filters.dateTo = this.formatDate(tomorrow);
        this.filters.status = '';
        break;
      case 'week':
        const weekEnd = new Date(today);
        weekEnd.setDate(weekEnd.getDate() + 7);
        this.filters.dateFrom = this.formatDate(today);
        this.filters.dateTo = this.formatDate(weekEnd);
        this.filters.status = '';
        break;
      case 'month':
        const monthEnd = new Date(today);
        monthEnd.setMonth(monthEnd.getMonth() + 1);
        this.filters.dateFrom = this.formatDate(today);
        this.filters.dateTo = this.formatDate(monthEnd);
        this.filters.status = '';
        break;
      default:
        this.filters.dateFrom = null;
        this.filters.dateTo = null;
        this.filters.status = '';
    }

    this.renderReservations();
    this.renderStats();
  }

  applyFilters() {
    console.log('[Reservations] Applying filters...');
    
    const dateFrom = document.getElementById('filterDateFrom');
    const dateTo = document.getElementById('filterDateTo');
    const status = document.getElementById('filterStatus');
    const roomType = document.getElementById('filterRoomType');
    const source = document.getElementById('filterSource');
    
    this.filters.dateFrom = dateFrom?.value || null;
    this.filters.dateTo = dateTo?.value || null;
    this.filters.status = status?.value || '';
    this.filters.roomType = roomType?.value || '';
    this.filters.source = source?.value || '';

    console.log('[Reservations] Filters applied:', this.filters);
    
    this.renderReservations();
    this.renderStats();
  }

  getFilteredReservations() {
    let reservations = [...this.reservationEngine.reservations];

    // Date range filter
    if (this.filters.dateFrom || this.filters.dateTo) {
      const from = this.filters.dateFrom ? new Date(this.filters.dateFrom) : new Date('1900-01-01');
      const to = this.filters.dateTo ? new Date(this.filters.dateTo) : new Date('2100-12-31');
      
      reservations = reservations.filter(r => {
        const checkIn = new Date(r.checkInDate);
        return checkIn >= from && checkIn <= to;
      });
    }

    // Status filter
    if (this.filters.status) {
      reservations = reservations.filter(r => r.status === this.filters.status);
    }

    // Room type filter
    if (this.filters.roomType) {
      reservations = reservations.filter(r => r.roomTypeId === this.filters.roomType);
    }

    // Source filter
    if (this.filters.source) {
      reservations = reservations.filter(r => r.source === this.filters.source);
    }

    // Search query
    if (this.searchQuery) {
      reservations = reservations.filter(r => {
        const searchStr = `${r.guestName} ${r.guestEmail} ${r.confirmationNumber}`.toLowerCase();
        return searchStr.includes(this.searchQuery);
      });
    }

    // Sort by check-in date (most recent first)
    reservations.sort((a, b) => new Date(a.checkInDate) - new Date(b.checkInDate));

    return reservations;
  }

  renderReservations() {
    const container = document.getElementById('reservationListView');
    if (!container) return;

    const reservations = this.getFilteredReservations();

    if (reservations.length === 0) {
      container.innerHTML = `
        <div class="empty-state">
          <div class="icon">üì≠</div>
          <h3>${this.t('resNoResults')}</h3>
          <p>${this.t('resNoResultsDesc')}</p>
        </div>
      `;
      return;
    }

  container.innerHTML = reservations.map(res => this.renderReservationItem(res)).join('');

    // Add click handlers
    container.querySelectorAll('.reservation-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (!e.target.closest('.res-action-btn')) {
          const resId = item.dataset.resId;
          this.openReservationDetails(resId);
        }
      });
    });

    // Action buttons
    container.querySelectorAll('.btn-edit').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const resId = btn.closest('.reservation-item').dataset.resId;
        this.openEditReservation(resId);
      });
    });

    container.querySelectorAll('.btn-cancel').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const resId = btn.closest('.reservation-item').dataset.resId;
        this.cancelReservation(resId);
      });
    });
  }

  renderReservationItem(res) {
    const statusLabels = {
      confirmed: this.t('resConfirmed'),
      pending: this.t('resPending'),
      cancelled: this.t('resCancelled'),
      checked_in: this.t('resCheckedIn'),
      checked_out: this.t('resCheckedOut')
    };

    const nightsText = res.nights === 1 ? this.t('resNights') : this.t('resNightsPlural');
    const adultsText = res.adults === 1 ? this.t('resAdult') : this.t('resAdultsPlural');
    const childrenText = res.children === 1 ? this.t('resChild') : this.t('resChildrenPlural');

    return `
      <div class="reservation-item" data-res-id="${res.id}">
        <div class="res-status">
          <span class="status-badge ${res.status}">${statusLabels[res.status] || res.status}</span>
        </div>
        <div class="res-guest">
          <h4>${this.escapeHtml(res.guestName)}</h4>
          <p>${res.confirmationNumber}</p>
          <p>${this.escapeHtml(res.guestEmail || '')}</p>
        </div>
        <div class="res-dates">
          <div><strong>Check-in:</strong> ${this.formatDateDisplay(res.checkInDate)}</div>
          <div><strong>Check-out:</strong> ${this.formatDateDisplay(res.checkOutDate)}</div>
          <div style="color: #64748b;">${res.nights} ${nightsText}</div>
        </div>
        <div class="res-room">
          ${res.roomNumber || res.roomTypeId.toUpperCase()}
          <div style="font-size: 11px; color: #64748b; font-weight: 400;">${res.adults} ${adultsText}${res.children > 0 ? `, ${res.children} ${childrenText}` : ''}</div>
        </div>
        <div class="res-rate">
          <div class="amount">${this.formatCurrency(res.totalAmount)}</div>
          <div class="nights">${this.formatCurrency(res.ratePerNight)}${this.t('resPerNight')}</div>
        </div>
        <div class="res-actions">
          <button class="btn res-action-btn btn-edit" title="${this.t('resEdit')}">‚úèÔ∏è</button>
          <button class="btn btn-danger res-action-btn btn-cancel" title="${this.t('resCancel')}">‚ùå</button>
        </div>
      </div>
    `;
  }

  renderCalendar() {
    const container = document.getElementById('reservationCalendarView');
    if (!container) return;

    // Use stored calendar date or today
    if (!this.calendarDate) {
      this.calendarDate = new Date();
    }
    
    const currentMonth = this.calendarDate.getMonth();
    const currentYear = this.calendarDate.getFullYear();

    // Get first and last day of month
    const firstDay = new Date(currentYear, currentMonth, 1);
    const lastDay = new Date(currentYear, currentMonth + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startDay = firstDay.getDay(); // 0 = Sunday

    // Month names
    const monthNames = ['Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho', 
                        'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'];

    // Get reservations for this month
    const monthStart = this.formatDate(firstDay);
    const monthEnd = this.formatDate(lastDay);
    
    const reservations = this.reservationEngine.reservations.filter(r => {
      return (r.checkInDate <= monthEnd && r.checkOutDate >= monthStart) && r.status !== 'cancelled';
    });

    // Build calendar HTML
    let html = `
      <div class="calendar-header">
        <button class="btn" onclick="window.reservationsUI.changeMonth(-1)">‚óÄ</button>
        <h3>${monthNames[currentMonth]} ${currentYear}</h3>
        <button class="btn" onclick="window.reservationsUI.changeMonth(1)">‚ñ∂</button>
      </div>
      <div class="calendar-grid">
        <div class="calendar-weekdays">
          <div>Dom</div><div>Seg</div><div>Ter</div><div>Qua</div>
          <div>Qui</div><div>Sex</div><div>S√°b</div>
        </div>
        <div class="calendar-days">
    `;

    // Empty cells before first day
    for (let i = 0; i < startDay; i++) {
      html += '<div class="calendar-day empty"></div>';
    }

    // Days of month
    const today = new Date(); // For comparison to mark today
    for (let day = 1; day <= daysInMonth; day++) {
      const date = new Date(currentYear, currentMonth, day);
      const dateStr = this.formatDate(date);
      const isToday = dateStr === this.formatDate(today);
      
      // Count reservations for this day
      const dayReservations = reservations.filter(r => {
        return r.checkInDate <= dateStr && r.checkOutDate >= dateStr;
      });

      const checkIns = reservations.filter(r => r.checkInDate === dateStr).length;
      const checkOuts = reservations.filter(r => r.checkOutDate === dateStr).length;

      html += `
        <div class="calendar-day ${isToday ? 'today' : ''} ${dayReservations.length > 0 ? 'has-reservations' : ''}"
             data-date="${dateStr}">
          <div class="day-number">${day}</div>
          ${dayReservations.length > 0 ? `
            <div class="day-info">
              <span class="badge">${dayReservations.length} ${this.t('resReservations') || 'reservas'}</span>
              ${checkIns > 0 ? `<span class="badge-in">‚Üì${checkIns}</span>` : ''}
              ${checkOuts > 0 ? `<span class="badge-out">‚Üë${checkOuts}</span>` : ''}
            </div>
          ` : ''}
        </div>
      `;
    }

    html += `
        </div>
      </div>
      <div class="calendar-legend">
        <span><span class="legend-badge badge-in">‚Üì</span> Check-in</span>
        <span><span class="legend-badge badge-out">‚Üë</span> Check-out</span>
        <span><span class="legend-badge today-marker">‚óè</span> Hoje</span>
      </div>
    `;

    container.innerHTML = html;

    // Add click handlers to days
    container.querySelectorAll('.calendar-day[data-date]').forEach(day => {
      day.addEventListener('click', () => {
        const date = day.dataset.date;
        this.showDayReservations(date);
      });
    });
  }

  changeMonth(offset) {
    // Store current month/year or use today
    if (!this.calendarDate) {
      this.calendarDate = new Date();
    }
    
    this.calendarDate.setMonth(this.calendarDate.getMonth() + offset);
    this.renderCalendar();
  }

  showDayReservations(date) {
    const reservations = this.reservationEngine.reservations.filter(r => {
      return r.checkInDate <= date && r.checkOutDate >= date && r.status !== 'cancelled';
    });

    if (reservations.length === 0) {
      alert(`Nenhuma reserva para ${this.formatDateDisplay(date)}`);
      return;
    }

    const details = reservations.map(r => {
      const isCheckIn = r.checkInDate === date;
      const isCheckOut = r.checkOutDate === date;
      let status = '';
      if (isCheckIn) status = '‚Üì Check-in';
      if (isCheckOut) status = '‚Üë Check-out';
      if (isCheckIn && isCheckOut) status = '‚Üì‚Üë Check-in/out';
      
      return `${status ? status + ' - ' : ''}${r.guestName} (${r.confirmationNumber})`;
    }).join('\n');

    alert(`Reservas em ${this.formatDateDisplay(date)}:\n\n${details}`);
  }

  renderTimeline() {
    const container = document.getElementById('reservationCalendarView');
    if (!container) return;

    // Use stored timeline start date or today
    if (!this.timelineStart) {
      this.timelineStart = new Date();
    }

    const today = new Date();
    const startDate = new Date(this.timelineStart);
    startDate.setDate(startDate.getDate() - 3); // Show 3 days before
    const endDate = new Date(this.timelineStart);
    endDate.setDate(endDate.getDate() + 14); // Show 14 days ahead

    // Get all reservations in range
    const startStr = this.formatDate(startDate);
    const endStr = this.formatDate(endDate);
    
    const reservations = this.reservationEngine.reservations.filter(r => {
      return (r.checkInDate <= endStr && r.checkOutDate >= startStr) && r.status !== 'cancelled';
    }).sort((a, b) => a.checkInDate.localeCompare(b.checkInDate));

    // Generate dates array
    const dates = [];
    const currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      dates.push(new Date(currentDate));
      currentDate.setDate(currentDate.getDate() + 1);
    }

    // Build timeline HTML
    let html = `
      <div class="timeline-header">
        <h3>Timeline - ${this.formatDateDisplay(startStr)} at√© ${this.formatDateDisplay(endStr)}</h3>
        <div class="timeline-controls">
          <button class="btn" onclick="window.reservationsUI.shiftTimeline(-7)">‚óÄ 7 dias</button>
          <button class="btn" onclick="window.reservationsUI.resetTimeline()">Hoje</button>
          <button class="btn" onclick="window.reservationsUI.shiftTimeline(7)">7 dias ‚ñ∂</button>
        </div>
      </div>
      <div class="timeline-container">
        <div class="timeline-dates">
          <div class="timeline-rooms-header">${this.t('resRoomType') || 'Quartos'}</div>
          ${dates.map(date => {
            const dateStr = this.formatDate(date);
            const isToday = dateStr === this.formatDate(today);
            const dayName = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'S√°b'][date.getDay()];
            return `
              <div class="timeline-date ${isToday ? 'today' : ''}">
                <div class="date-day">${dayName}</div>
                <div class="date-number">${date.getDate()}</div>
              </div>
            `;
          }).join('')}
        </div>
        <div class="timeline-grid">
    `;

    // Room types (simplified - in real app would come from room inventory)
    const roomTypes = [
      { id: 'standard', name: 'Standard', count: 10 },
      { id: 'deluxe', name: 'Deluxe', count: 8 },
      { id: 'suite', name: 'Suite', count: 5 }
    ];

    roomTypes.forEach(roomType => {
      const roomReservations = reservations.filter(r => r.roomTypeId === roomType.id);
      
      html += `
        <div class="timeline-row">
          <div class="timeline-room-label">
            ${roomType.name}
            <span class="room-count">${roomType.count} ${this.t('resRooms') || 'quartos'}</span>
          </div>
          <div class="timeline-cells">
      `;

      // Draw timeline cells
      dates.forEach(date => {
        const dateStr = this.formatDate(date);
        const dayReservations = roomReservations.filter(r => {
          return r.checkInDate <= dateStr && r.checkOutDate >= dateStr;
        });

        const occupancy = Math.min(100, (dayReservations.length / roomType.count) * 100);
        const isToday = dateStr === this.formatDate(today);
        
        html += `
          <div class="timeline-cell ${isToday ? 'today' : ''}" 
               data-date="${dateStr}"
               data-room-type="${roomType.id}"
               style="background: linear-gradient(to top, #4CAF50 ${occupancy}%, transparent ${occupancy}%);"
               title="${dayReservations.length}/${roomType.count} ocupados">
            ${dayReservations.length > 0 ? `<span class="cell-count">${dayReservations.length}</span>` : ''}
          </div>
        `;
      });

      html += `
          </div>
        </div>
      `;
    });

    html += `
        </div>
      </div>
      <div class="timeline-legend">
        <span><span class="legend-bar" style="background: #4CAF50"></span> Ocupado</span>
        <span><span class="legend-bar" style="background: transparent; border: 1px solid #ddd"></span> Dispon√≠vel</span>
        <span><span class="legend-badge today-marker">‚óè</span> Hoje</span>
      </div>
      
      <div class="timeline-reservations">
        <h4>${this.t('resReservationDetails') || 'Detalhes das Reservas'}</h4>
        <div class="timeline-res-list">
          ${reservations.length === 0 ? `
            <div class="empty-state-small">Nenhuma reserva no per√≠odo</div>
          ` : reservations.map(r => {
            const checkIn = new Date(r.checkInDate);
            const checkOut = new Date(r.checkOutDate);
            const nights = Math.ceil((checkOut - checkIn) / (1000 * 60 * 60 * 24));
            
            return `
              <div class="timeline-res-item" data-res-id="${r.id}">
                <div class="res-bar" style="
                  left: ${this.getTimelinePosition(r.checkInDate, startStr, endStr, dates.length)}%;
                  width: ${(nights / dates.length) * 100}%;
                  background: ${this.getStatusColor(r.status)};
                ">
                  <span class="res-label">${r.guestName}</span>
                </div>
                <div class="res-details">
                  <strong>${r.guestName}</strong> - ${r.confirmationNumber}<br>
                  ${this.formatDateDisplay(r.checkInDate)} ‚Üí ${this.formatDateDisplay(r.checkOutDate)}
                  (${nights} ${this.t('resNights') || 'noites'})<br>
                  ${this.getRoomTypeLabel(r.roomTypeId)} - ${this.formatCurrency(r.totalAmount)}
                </div>
              </div>
            `;
          }).join('')}
        </div>
      </div>
    `;

    container.innerHTML = html;

    // Add click handlers
    container.querySelectorAll('.timeline-cell').forEach(cell => {
      cell.addEventListener('click', () => {
        const date = cell.dataset.date;
        const roomType = cell.dataset.roomType;
        this.showTimelineDay(date, roomType);
      });
    });

    container.querySelectorAll('.timeline-res-item').forEach(item => {
      item.addEventListener('click', () => {
        const resId = item.dataset.resId;
        this.openReservationDetails(resId);
      });
    });
  }

  getTimelinePosition(checkInDate, startDate, endDate, totalDays) {
    const checkIn = new Date(checkInDate);
    const start = new Date(startDate);
    const diffDays = Math.ceil((checkIn - start) / (1000 * 60 * 60 * 24));
    return (diffDays / totalDays) * 100;
  }

  getStatusColor(status) {
    const colors = {
      'confirmed': '#4CAF50',
      'pending': '#FF9800',
      'checked_in': '#2196F3',
      'checked_out': '#9E9E9E',
      'cancelled': '#F44336'
    };
    return colors[status] || '#9E9E9E';
  }

  getRoomTypeLabel(roomTypeId) {
    const labels = {
      'standard': 'Standard',
      'deluxe': 'Deluxe',
      'suite': 'Suite'
    };
    return labels[roomTypeId] || roomTypeId;
  }

  shiftTimeline(days) {
    if (!this.timelineStart) {
      this.timelineStart = new Date();
    }
    this.timelineStart.setDate(this.timelineStart.getDate() + days);
    this.renderTimeline();
  }

  resetTimeline() {
    this.timelineStart = new Date();
    this.renderTimeline();
  }

  showTimelineDay(date, roomType) {
    const reservations = this.reservationEngine.reservations.filter(r => {
      return r.checkInDate <= date && r.checkOutDate >= date && 
             r.roomTypeId === roomType && r.status !== 'cancelled';
    });

    if (reservations.length === 0) {
      alert(`Nenhuma reserva de ${this.getRoomTypeLabel(roomType)} em ${this.formatDateDisplay(date)}`);
      return;
    }

    const details = reservations.map(r => 
      `${r.guestName} (${r.confirmationNumber})`
    ).join('\n');

    alert(`Reservas ${this.getRoomTypeLabel(roomType)} em ${this.formatDateDisplay(date)}:\n\n${details}`);
  }

  renderStats() {
    const today = new Date();
    const todayStr = this.formatDate(today);
    const thirtyDaysLater = new Date(today);
    thirtyDaysLater.setDate(thirtyDaysLater.getDate() + 30);

    // Today's arrivals
    const arrivals = this.reservationEngine.reservations.filter(r => 
      r.checkInDate === todayStr && (r.status === 'confirmed' || r.status === 'pending')
    );

    // Today's departures
    const departures = this.reservationEngine.reservations.filter(r => 
      r.checkOutDate === todayStr && r.status === 'checked_in'
    );

    // In-house guests
    const inHouse = this.reservationEngine.reservations.filter(r => 
      r.status === 'checked_in'
    );

    // Revenue next 30 days
    const revenue = this.reservationEngine.reservations
      .filter(r => {
        const checkIn = new Date(r.checkInDate);
        return checkIn >= today && checkIn <= thirtyDaysLater && r.status !== 'cancelled';
      })
      .reduce((sum, r) => sum + (r.totalAmount || 0), 0);

    // Update DOM
    this.updateElement('statArrivalsValue', arrivals.length);
    this.updateElement('statArrivalsSubvalue', arrivals.length);
    this.updateElement('statDeparturesValue', departures.length);
    this.updateElement('statDeparturesSubvalue', departures.length);
    this.updateElement('statInHouseValue', inHouse.length);
    this.updateElement('statInHouseSubvalue', inHouse.length);
    this.updateElement('statRevenueValue', this.formatCurrency(revenue));
  }

  updateAvailability() {
    const today = new Date();
    const todayStr = this.formatDate(today);
    
    console.log('[Reservations] Updating availability for:', todayStr);
    
    // Count in-house guests manually for debug
    const inHouseCount = this.reservationEngine.reservations.filter(r => r.status === 'checked_in').length;
    console.log('[Reservations] In-house guests (checked_in):', inHouseCount);
    
    // Get availability for TODAY (not tomorrow)
    const availability = this.reservationEngine.getAvailability(todayStr);
    
    console.log('[Reservations] Availability result:', availability);

    this.updateElement('availableRooms', availability.available);
    this.updateElement('occupancyRate', `${availability.occupancy}%`);
  }

  refreshData() {
    this.renderReservations();
    this.renderStats();
    this.updateAvailability();
  }

  // Modal Actions
  openNewReservationModal() {
    console.log('[Reservations] Opening new reservation modal...');
    
    const modal = document.getElementById('newReservationModal');
    if (!modal) {
      console.error('[Reservations] Modal element not found!');
      alert('Erro: Modal n√£o encontrado. Recarregue a p√°gina.');
      return;
    }

    // Reset editing state
    this.editMode = false;
    this.editingReservationId = null;

    // Reset form
    const form = document.getElementById('newReservationForm');
    if (form) {
      form.reset();
      console.log('[Reservations] Form reset');
    }
    
    // Set default dates (today + 1 day for check-in, +2 days for check-out)
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const dayAfter = new Date(today);
    dayAfter.setDate(dayAfter.getDate() + 2);
    
    const checkInInput = document.getElementById('checkInDate');
    const checkOutInput = document.getElementById('checkOutDate');
    
    if (checkInInput) checkInInput.value = this.formatDate(tomorrow);
    if (checkOutInput) checkOutInput.value = this.formatDate(dayAfter);
    
    const countryInput = document.getElementById('guestCountry');
    if (countryInput) countryInput.value = 'Brasil';
    
    const adultsInput = document.getElementById('adults');
    if (adultsInput) adultsInput.value = 2;
    
    const childrenInput = document.getElementById('children');
    if (childrenInput) childrenInput.value = 0;
    
    const depositInput = document.getElementById('depositAmount');
    if (depositInput) depositInput.value = 0;
    
  // Modal title & save button for NEW mode
  const titleEl = document.querySelector('#newReservationModal .modal-header h2');
  if (titleEl) titleEl.textContent = this.t('resNewResTitle') || 'Nova Reserva';
  const saveBtn = document.querySelector('#newReservationModal .form-actions .btn.btn-primary');
  if (saveBtn) saveBtn.textContent = this.t('resBtnSave') || 'Salvar Reserva';

  // Calculate initial values
    this.updateReservationCalculations();
    
    // Apply translations to modal
    this.applyTranslations();
    
    // Show modal
    modal.style.display = 'flex';
    console.log('[Reservations] Modal opened');
  }

  // Unified submit handler
  handleReservationSubmit() {
    if (this.editMode && this.editingReservationId) {
      this.saveEditedReservation();
    } else {
      this.saveNewReservation();
    }
  }

  updateReservationCalculations() {
    console.log('[Reservations] Updating calculations...');
    
    const checkInDate = document.getElementById('checkInDate')?.value;
    const checkOutDate = document.getElementById('checkOutDate')?.value;
    const roomTypeId = document.getElementById('roomTypeId')?.value;
    const ratePlanId = document.getElementById('ratePlanId')?.value || 'rack';
    const adultsInput = document.getElementById('adults');
    const adults = adultsInput ? parseInt(adultsInput.value) || 2 : 2;

    // Calculate nights
    if (checkInDate && checkOutDate) {
      const nights = this.reservationEngine.calculateNights(checkInDate, checkOutDate);
      const nightsText = nights === 1 ? this.t('resNights') : this.t('resNightsPlural');
      const nightsDisplay = document.getElementById('nightsDisplay');
      if (nightsDisplay) {
        nightsDisplay.value = `${nights} ${nightsText}`;
      }
      console.log('[Reservations] Calculated nights:', nights);

      // Calculate rate if room type is selected
      if (roomTypeId && this.ratePlan) {
        try {
          const rateInfo = this.ratePlan.calculateRate(roomTypeId, checkInDate, checkOutDate, ratePlanId, adults);
          
          if (rateInfo) {
            const rateInput = document.getElementById('ratePerNight');
            const totalInput = document.getElementById('totalAmount');
            
            if (rateInput) rateInput.value = rateInfo.finalRate.toFixed(2);
            if (totalInput) totalInput.value = (rateInfo.finalRate * nights).toFixed(2);
            
            console.log('[Reservations] Calculated rate:', rateInfo.finalRate, 'total:', rateInfo.finalRate * nights);
          }
        } catch (e) {
          console.error('[Reservations] Error calculating rate:', e);
        }
      }
    }
  }

  checkAvailabilityForNewRes() {
    const checkInDate = document.getElementById('checkInDate').value;
    const checkOutDate = document.getElementById('checkOutDate').value;
    const roomTypeId = document.getElementById('roomTypeId').value;
    const resultDiv = document.getElementById('availabilityResult');

    if (!checkInDate || !checkOutDate || !roomTypeId) {
      resultDiv.innerHTML = `<span style="color: #f59e0b;">‚ö†Ô∏è ${this.t('resRequiredField')}</span>`;
      return;
    }

    // Check dates validity
    if (new Date(checkOutDate) <= new Date(checkInDate)) {
      resultDiv.innerHTML = `<span style="color: #ef4444;">‚ùå ${this.t('resCheckOutBeforeCheckIn')}</span>`;
      return;
    }

    resultDiv.innerHTML = `<span style="color: #64748b;">‚è≥ ${this.t('resAvailabilityCheck')}</span>`;

    // Simulate API call delay
    setTimeout(() => {
      const availability = this.reservationEngine.getAvailability(checkInDate, checkOutDate, roomTypeId);
      
      if (availability.available > 0) {
        resultDiv.innerHTML = `<span style="color: #10b981;">‚úÖ ${this.t('resAvailabilityYes')} (${availability.available} ${this.t('resAvailableRooms')})</span>`;
      } else {
        resultDiv.innerHTML = `<span style="color: #ef4444;">‚ùå ${this.t('resAvailabilityNo')}</span>`;
      }
    }, 500);
  }

  saveNewReservation() {
    // Get form data
    const formData = {
      guestName: document.getElementById('guestName').value,
      guestEmail: document.getElementById('guestEmail').value,
      guestPhone: document.getElementById('guestPhone').value,
      guestDocument: document.getElementById('guestDocument').value,
      guestCountry: document.getElementById('guestCountry').value,
      
      checkInDate: document.getElementById('checkInDate').value,
      checkOutDate: document.getElementById('checkOutDate').value,
      
      roomTypeId: document.getElementById('roomTypeId').value,
      adults: parseInt(document.getElementById('adults').value),
      children: parseInt(document.getElementById('children').value),
      
      ratePlanId: document.getElementById('ratePlanId').value,
      ratePerNight: parseFloat(document.getElementById('ratePerNight').value),
      totalAmount: parseFloat(document.getElementById('totalAmount').value),
      
      paymentMethod: document.getElementById('paymentMethod').value,
      paymentStatus: document.getElementById('paymentStatus').value,
      depositAmount: parseFloat(document.getElementById('depositAmount').value),
      
      source: document.getElementById('source').value,
      otaName: document.getElementById('otaName').value || null,
      
      specialRequests: document.getElementById('specialRequests').value ? 
        [document.getElementById('specialRequests').value] : [],
      
      status: 'confirmed',
      createdBy: 'pms_user' // TODO: Get from auth system
    };

    // Validate
    if (!formData.guestName || !formData.guestEmail || !formData.checkInDate || !formData.checkOutDate || !formData.roomTypeId) {
      alert(this.t('resRequiredField'));
      return;
    }

    // Validate email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(formData.guestEmail)) {
      alert(this.t('resInvalidEmail'));
      return;
    }

    // Validate dates
    if (new Date(formData.checkOutDate) <= new Date(formData.checkInDate)) {
      alert(this.t('resCheckOutBeforeCheckIn'));
      return;
    }

    try {
      // Create reservation
      const reservation = this.reservationEngine.createReservation(formData);
      
      console.log('[Reservation] Created successfully:', reservation);
      
      // Show success message
      alert(`${this.t('resSaveSuccess')}\n\n${this.t('resConfirmationNumber')}: ${reservation.confirmationNumber}`);
      
      // Close modal
      document.getElementById('newReservationModal').style.display = 'none';
      
      // Refresh data
      this.refreshData();
      
    } catch (error) {
      console.error('[Reservation] Error saving:', error);
      alert(this.t('resSaveError'));
    }
  }

  openReservationDetails(resId) {
    const reservation = this.reservationEngine.reservations.find(r => r.id === resId);
    if (!reservation) return;

    console.log('Opening reservation details:', reservation);
    alert(`Detalhes da Reserva:\n\nConfirma√ß√£o: ${reservation.confirmationNumber}\nH√≥spede: ${reservation.guestName}\nCheck-in: ${this.formatDateDisplay(reservation.checkInDate)}\nCheck-out: ${this.formatDateDisplay(reservation.checkOutDate)}\nTotal: ${this.formatCurrency(reservation.totalAmount)}`);
  }

  openEditReservation(resId) {
    const reservation = this.reservationEngine.reservations.find(r => r.id === resId);
    if (!reservation) return;

    console.log('[Reservations] Editing reservation:', reservation);

    // Set edit state
    this.editMode = true;
    this.editingReservationId = resId;

    // Open modal and populate fields
    const modal = document.getElementById('newReservationModal');
    if (!modal) return alert('Modal n√£o encontrado');

    const form = document.getElementById('newReservationForm');
    if (form) form.reset();

    // Populate form fields
    const setVal = (id, v) => { const el = document.getElementById(id); if (el) el.value = v ?? ''; };
    setVal('guestName', reservation.guestName);
    setVal('guestEmail', reservation.guestEmail);
    setVal('guestPhone', reservation.guestPhone);
    setVal('guestDocument', reservation.guestDocument);
    setVal('guestCountry', reservation.guestCountry || 'Brasil');

    setVal('checkInDate', reservation.checkInDate);
    setVal('checkOutDate', reservation.checkOutDate);
    setVal('roomTypeId', reservation.roomTypeId);
    setVal('adults', reservation.adults);
    setVal('children', reservation.children);

    setVal('ratePlanId', reservation.ratePlanId || 'rack');
    setVal('ratePerNight', reservation.ratePerNight);
    setVal('totalAmount', reservation.totalAmount);

    setVal('paymentMethod', reservation.paymentMethod || 'credit_card');
    setVal('paymentStatus', reservation.paymentStatus || 'pending');
    setVal('depositAmount', reservation.depositAmount || 0);

    setVal('source', reservation.source || 'direct');
    setVal('otaName', reservation.otaName || '');

    const specialReq = Array.isArray(reservation.specialRequests) && reservation.specialRequests.length > 0
      ? reservation.specialRequests.join('; ')
      : '';
    setVal('specialRequests', specialReq);

    // Update nights field
    this.updateReservationCalculations();

    // Adjust modal title and save button for EDIT mode
    const titleEl = document.querySelector('#newReservationModal .modal-header h2');
    if (titleEl) titleEl.textContent = this.t('resEditReservation') || 'Editar Reserva';
    const saveBtn = document.querySelector('#newReservationModal .form-actions .btn.btn-primary');
    if (saveBtn) saveBtn.textContent = this.t('resBtnSaveChanges') || 'Salvar Altera√ß√µes';

    // Show modal
    modal.style.display = 'flex';
  }

  saveEditedReservation() {
    const id = this.editingReservationId;
    const r = this.reservationEngine.reservations.find(x => x.id === id);
    if (!r) { alert('Reserva n√£o encontrada'); return; }

    // Gather form data
    const updates = {
      guestName: document.getElementById('guestName').value,
      guestEmail: document.getElementById('guestEmail').value,
      guestPhone: document.getElementById('guestPhone').value,
      guestDocument: document.getElementById('guestDocument').value,
      guestCountry: document.getElementById('guestCountry').value,
      checkInDate: document.getElementById('checkInDate').value,
      checkOutDate: document.getElementById('checkOutDate').value,
      roomTypeId: document.getElementById('roomTypeId').value,
      adults: parseInt(document.getElementById('adults').value),
      children: parseInt(document.getElementById('children').value) || 0,
      ratePlanId: document.getElementById('ratePlanId').value,
      ratePerNight: parseFloat(document.getElementById('ratePerNight').value),
      totalAmount: parseFloat(document.getElementById('totalAmount').value),
      paymentMethod: document.getElementById('paymentMethod').value,
      paymentStatus: document.getElementById('paymentStatus').value,
      depositAmount: parseFloat(document.getElementById('depositAmount').value) || 0,
      source: document.getElementById('source').value,
      otaName: document.getElementById('otaName').value || null,
      specialRequests: (document.getElementById('specialRequests').value || '')
        .split(';')
        .map(s => s.trim())
        .filter(Boolean)
    };

    // Basic validations
    if (!updates.guestName || !updates.guestEmail || !updates.checkInDate || !updates.checkOutDate || !updates.roomTypeId) {
      alert(this.t('resRequiredField'));
      return;
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(updates.guestEmail)) {
      alert(this.t('resInvalidEmail'));
      return;
    }
    if (new Date(updates.checkOutDate) <= new Date(updates.checkInDate)) {
      alert(this.t('resCheckOutBeforeCheckIn'));
      return;
    }

    // Validate availability excluding this reservation
    const avail = this.reservationEngine.checkAvailability(
      updates.roomTypeId,
      updates.checkInDate,
      updates.checkOutDate,
      1,
      id
    );
    if (!avail.available) {
      alert(this.t('resAvailabilityNo') || 'Sem disponibilidade para o per√≠odo/tipo de quarto');
      return;
    }

    // Recalculate nights
    updates.nights = this.reservationEngine.calculateNights(updates.checkInDate, updates.checkOutDate);

    try {
      const updated = this.reservationEngine.updateReservation(id, updates);
      if (!updated) throw new Error('update_failed');

      alert(this.t('resSaveSuccess') || 'Salvo com sucesso');
      document.getElementById('newReservationModal').style.display = 'none';
      this.refreshData();
    } catch (e) {
      console.error('[Reservations] Update error:', e);
      alert(this.t('resSaveError') || 'Erro ao salvar altera√ß√µes');
    }
  }

  cancelReservation(resId) {
    if (!confirm(this.t('resCancelConfirm'))) return;

    const result = this.reservationEngine.cancelReservation(resId, 'guest_request');
    
    if (result) {
      alert(this.t('resCancelSuccess'));
      this.refreshData();
    } else {
      alert(this.t('resCancelError'));
    }
  }

  exportReservations() {
    const reservations = this.getFilteredReservations();
    
    // Create CSV
    const headers = ['Confirma√ß√£o', 'H√≥spede', 'Email', 'Check-in', 'Check-out', 'Noites', 'Quarto', 'Status', 'Total'];
    const rows = reservations.map(r => [
      r.confirmationNumber,
      r.guestName,
      r.guestEmail || '',
      r.checkInDate,
      r.checkOutDate,
      r.nights,
      r.roomNumber || r.roomTypeId,
      r.status,
      r.totalAmount
    ]);

    const csv = [headers, ...rows].map(row => row.join(',')).join('\n');
    
    // Download
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `reservas_${Date.now()}.csv`;
    a.click();
    
    console.log('Exported', reservations.length, 'reservations');
  }

  // Utility Methods
  formatDate(date) {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  formatDateDisplay(dateStr) {
    if (!dateStr) return '-';
    const [year, month, day] = dateStr.split('-');
    return `${day}/${month}/${year}`;
  }

  formatCurrency(amount) {
    // Map language to locale and currency
    const currencyMap = {
      'pt': { locale: 'pt-BR', currency: 'BRL' },
      'en': { locale: 'en-US', currency: 'USD' },
      'es': { locale: 'es-ES', currency: 'EUR' }
    };
    
    const config = currencyMap[this.currentLang] || currencyMap['pt'];
    
    return new Intl.NumberFormat(config.locale, {
      style: 'currency',
      currency: config.currency
    }).format(amount || 0);
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  updateElement(id, value) {
    const el = document.getElementById(id);
    if (el) el.textContent = value;
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Check if sample data generation is disabled (for production)
  const sampleDataDisabled = localStorage.getItem('pms_disable_sample_data') === 'true';
  
  if (sampleDataDisabled) {
    console.log('[Reservations] ‚ö†Ô∏è  Sample data generation DISABLED (Production Mode)');
    console.log('[Reservations] To re-enable: PMSDataManager.enableSampleDataGeneration()');
  } else {
    console.log('[Reservations] üìä Sample data generation ENABLED (Demo Mode)');
    
    // Generate sample data if empty
    const propertyKey = 'property_default';
    const engine = window.getReservationEngine(propertyKey);
    
    if (engine.reservations.length === 0) {
      console.log('[Reservations] Generating sample data...');
      generateSampleReservations(engine);
    } else {
      console.log('[Reservations] Using existing reservations:', engine.reservations.length);
    }
  }

  // Initialize UI
  window.reservationsUI = new ReservationsUIController();
});

// Sample Data Generator
function generateSampleReservations(engine) {
  // Helper function to format date to YYYY-MM-DD
  const formatDate = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const today = new Date();
  const names = ['Jo√£o Silva', 'Maria Santos', 'Carlos Oliveira', 'Ana Costa', 'Pedro Almeida', 'Juliana Souza', 'Roberto Lima', 'Fernanda Rocha', 'Lucas Ferreira', 'Patricia Mendes'];
  const emails = ['joao@email.com', 'maria@email.com', 'carlos@email.com', 'ana@email.com', 'pedro@email.com', 'juliana@email.com', 'roberto@email.com', 'fernanda@email.com', 'lucas@email.com', 'patricia@email.com'];
  const roomTypes = ['standard', 'deluxe', 'suite'];
  const sources = ['direct', 'ota', 'phone', 'corporate'];

  // Create 5 IN-HOUSE guests (checked-in, currently staying)
  for (let i = 0; i < 5; i++) {
    const checkInDate = new Date(today);
    checkInDate.setDate(checkInDate.getDate() - Math.floor(Math.random() * 3) - 1); // 1-3 days ago
    
    const nights = Math.floor(Math.random() * 4) + 2; // 2-5 nights
    const checkOutDate = new Date(checkInDate);
    checkOutDate.setDate(checkOutDate.getDate() + nights);

    const roomTypeId = roomTypes[Math.floor(Math.random() * roomTypes.length)];
    const ratePerNight = roomTypeId === 'standard' ? 350 : roomTypeId === 'deluxe' ? 500 : 800;
    const totalAmount = ratePerNight * nights;

    engine.createReservation({
      guestName: names[i],
      guestEmail: emails[i],
      guestPhone: `(11) ${Math.floor(Math.random() * 90000) + 10000}-${Math.floor(Math.random() * 9000) + 1000}`,
      checkInDate: formatDate(checkInDate),
      checkOutDate: formatDate(checkOutDate),
      roomTypeId,
      adults: Math.floor(Math.random() * 2) + 1,
      children: Math.random() > 0.7 ? Math.floor(Math.random() * 2) : 0,
      ratePerNight,
      totalAmount,
      source: sources[Math.floor(Math.random() * sources.length)],
      status: 'checked_in', // ALWAYS checked_in for in-house guests
      createdBy: 'sample_generator'
    });
  }

  // Create 10 FUTURE reservations (confirmed, pending)
  const futureStatuses = ['confirmed', 'confirmed', 'confirmed', 'pending'];
  for (let i = 5; i < 15; i++) {
    const checkInDate = new Date(today);
    checkInDate.setDate(checkInDate.getDate() + Math.floor(Math.random() * 25) + 1); // 1-25 days in future
    
    const nights = Math.floor(Math.random() * 5) + 1;
    const checkOutDate = new Date(checkInDate);
    checkOutDate.setDate(checkOutDate.getDate() + nights);

    const roomTypeId = roomTypes[Math.floor(Math.random() * roomTypes.length)];
    const ratePerNight = roomTypeId === 'standard' ? 350 : roomTypeId === 'deluxe' ? 500 : 800;
    const totalAmount = ratePerNight * nights;

    engine.createReservation({
      guestName: names[i % names.length],
      guestEmail: emails[i % emails.length],
      guestPhone: `(11) ${Math.floor(Math.random() * 90000) + 10000}-${Math.floor(Math.random() * 9000) + 1000}`,
      checkInDate: formatDate(checkInDate),
      checkOutDate: formatDate(checkOutDate),
      roomTypeId,
      adults: Math.floor(Math.random() * 2) + 1,
      children: Math.random() > 0.7 ? Math.floor(Math.random() * 2) : 0,
      ratePerNight,
      totalAmount,
      source: sources[Math.floor(Math.random() * sources.length)],
      status: futureStatuses[Math.floor(Math.random() * futureStatuses.length)],
      createdBy: 'sample_generator'
    });
  }

  console.log('[Reservations] Generated', engine.reservations.length, 'sample reservations');
}
