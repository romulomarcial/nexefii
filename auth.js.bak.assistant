/**
 * iLuxSys Authentication System
 * NEXEFII Authentication Module
 * Manages user registration, authorization, and authentication
 * Simple authentication for demo/development
 */

const AUTH_STORAGE_KEY = 'iluxsys_users';
const AUTH_SESSION_KEY = 'iluxsys_session';

const IluxAuth = {
  // Validate user credentials
  async login(email, password) {
    // Demo users
    const users = [
      {
        email: 'admin@nexefii.com',
        password: 'admin123',
        name: 'Admin NEXEFII',
        role: 'admin',
        properties: []
      },
      {
        email: 'demo@nexefii.com',
        password: 'demo123',
        name: 'Demo User',
        role: 'user',
        properties: []
      }
    ];

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 500));

    const user = users.find(u => u.email === email && u.password === password);
    if (!user) {
      throw new Error('Email ou senha invÃ¡lidos');
    }


  // Create session (remove password)
  const session = {
    email: user.email,
    name: user.name,
    role: user.role,
    properties: user.properties,
    loginAt: new Date().toISOString()
  };
  // Store session
  localStorage.setItem('nexefii_session', JSON.stringify(session));
  return session;
  },

  // Logout user
  logout() {
    localStorage.removeItem('nexefii_session');
    window.location.href = '/login.html';
  },

  // Get current session
  getSession() {
    const sessionData = localStorage.getItem('nexefii_session');
    if (!sessionData) return null;
    try {
      return JSON.parse(sessionData);
    } catch (e) {
      return null;
    }
  },

  // Check if user is authenticated
  isAuthenticated() {
    return this.getSession() !== null;
  }
  ,
  // Backwards-compatible alias used by older call sites
  getCurrentSession() {
    return this.getSession();
  },
  // Allow external scripts to set a session object in storage (keeps both keys for compatibility)
  setSession(session) {
    try {
      if (!session) return;
      localStorage.setItem('iluxsys_session', JSON.stringify(session));
      localStorage.setItem('nexefii_session', JSON.stringify(session));
    } catch (e) {
      console.warn('IluxAuth.setSession failed', e);
    }
  }
}; // End IluxAuth object

// User status types
const USER_STATUS = {
  PENDING: 'pending',    // Waiting for admin approval
  APPROVED: 'approved',  // Authorized to access
  DENIED: 'denied'       // Access denied
};

// Available system modules
const MODULES = {
  ENGINEERING: 'engineering',
  HOUSEKEEPING: 'housekeeping',
  ALERTS: 'alerts',
  COMMERCIAL: 'commercial',
  MARKETING: 'marketing',
  REPORTS: 'reports',
  MANAGEMENT: 'management'
};

// Module display names for i18n
const MODULE_NAMES = {
  pt: {
    engineering: 'Engenharia',
    housekeeping: 'GovernanÃ§a',
    alerts: 'Alertas',
    commercial: 'Comercial',
    marketing: 'Marketing',
    reports: 'RelatÃ³rios',
    management: 'Gerencial'
  },
  en: {
    engineering: 'Engineering',
    housekeeping: 'Housekeeping',
    alerts: 'Alerts',
    commercial: 'Commercial',
    marketing: 'Marketing',
    reports: 'Reports',
    management: 'Management'
  },
  es: {
    engineering: 'IngenierÃ­a',
    housekeeping: 'Gobernanza',
    alerts: 'Alertas',
    commercial: 'Comercial',
    marketing: 'Marketing',
    reports: 'Informes',
    management: 'Gerencial'
  }
};

// Initialization logic for admin and demo users should be inside a function, not at top-level
function initializeAuth() {
  let users = getUsers();
  // Create admin user if not exists
  const adminExists = users.some(u => u.username === 'admin');
  if (!adminExists) {
    users.push({
      id: generateUserId(),
      fullName: 'Administrator',
      email: 'admin@iluxsys.com',
      phone: '',
      country: 'BR',
      propertyKey: null,
      properties: [], // Empty means access to ALL properties
      position: 'Administrator',
      username: 'admin',
      password: hashPassword('admin12345!@#'),
      status: USER_STATUS.APPROVED,
      role: 'admin',
      modules: Object.values(MODULES), // Admin has access to all modules
      createdAt: new Date().toISOString(),
      approvedAt: new Date().toISOString()
    });
    saveUsers(users);
  }
  // Create demo user with specific property access
  const demoExists = users.some(u => u.username === 'demo');
  if (!demoExists) {
    users.push({
      id: generateUserId(),
      fullName: 'Demo User',
      email: 'demo@iluxsys.com',
      phone: '',
      country: 'BR',
      propertyKey: 'iluxSaoPaulo',
      properties: ['iluxSaoPaulo', 'iluxMiami'], // Access to specific properties
      position: 'Property Manager',
      username: 'demo',
      password: hashPassword('demo123'),
      status: USER_STATUS.APPROVED,
      role: 'manager',
      modules: ['engineering', 'housekeeping', 'alerts'],
      createdAt: new Date().toISOString(),
      approvedAt: new Date().toISOString()
    });
    saveUsers(users);
    console.info('âœ… Demo user created - Username: demo | Password: demo123 | Properties: SÃ£o Paulo, Miami');
  }
}

// Simple hash function (in production use bcrypt or similar)
function hashPassword(password) {
  // Basic hash - in production use proper hashing like bcrypt
  let hash = 0;
  const str = password + 'iluxsys_salt_2025';
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash.toString(16);
}

// Generate unique user ID
function generateUserId() {
  return 'usr_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Get all users from localStorage
function getUsers() {
  try {
    const data = localStorage.getItem(AUTH_STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch (e) {
    console.error('Error loading users:', e);
    return [];
  }
}

// Save users to localStorage
function saveUsers(users) {
  try {
    localStorage.setItem(AUTH_STORAGE_KEY, JSON.stringify(users));
    return true;
  } catch (e) {
    console.error('Error saving users:', e);
    return false;
  }
}

// Register new user (status: pending)
function registerUser(userData) {
  const users = getUsers();
  
  // Check if username already exists
  if (users.some(u => u.username === userData.username)) {
    return { success: false, error: 'username_exists' };
  }
  
  // Check if email already exists
  if (users.some(u => u.email === userData.email)) {
    return { success: false, error: 'email_exists' };
  }
  
  // Create new user
  const newUser = {
    id: generateUserId(),
    fullName: userData.fullName,
    email: userData.email,
    phone: userData.phone,
    country: userData.country,
    propertyKey: userData.propertyKey || null,
    position: userData.position || '',
    username: userData.username,
    password: hashPassword(userData.password),
    status: USER_STATUS.PENDING,
    role: 'user',
      modules: userData.modules || [], // Store requested modules
      requestedModules: userData.modules || [], // Keep original request
    createdAt: new Date().toISOString(),
    approvedAt: null
  };
  
  users.push(newUser);
  saveUsers(users);
  
  // Simulate email notification
  sendRegistrationEmail(newUser);
  
  return { success: true, userId: newUser.id };
}

// Authenticate user
function authenticateUser(username, password) {
  const users = getUsers();
  const hashedPassword = hashPassword(password);
  
  const user = users.find(u => 
    u.username === username && 
    u.password === hashedPassword
  );
  
  if (!user) {
    return { success: false, error: 'invalid_credentials' };
  }
  
  if (user.status !== USER_STATUS.APPROVED) {
    return { success: false, error: 'user_not_approved', status: user.status };
  }
  
  // Update user stats
  user.lastLogin = new Date().toISOString();
  user.loginCount = (user.loginCount || 0) + 1;
  saveUsers(users);
  
  // Create session
  const session = {
    userId: user.id,
    username: user.username,
    fullName: user.fullName,
    email: user.email,
    propertyKey: user.propertyKey || null,
    role: user.role,
    loginAt: new Date().toISOString()
  };
  
  localStorage.setItem(AUTH_SESSION_KEY, JSON.stringify(session));
  localStorage.setItem('ilux_user', user.email); // Backward compatibility
  localStorage.setItem('currentUser', JSON.stringify(user)); // For Master Control Panel
  
  // Let caller decide redirect (login.html will handle master redirect)
  return { success: true, user: session };
}

// Check if user is authenticated
function isAuthenticated() {
  try {
    const session = localStorage.getItem(AUTH_SESSION_KEY);
    return session !== null;
  } catch (e) {
    return false;
  }
}

// Get current session
function getCurrentSession() {
  try {
    const session = localStorage.getItem(AUTH_SESSION_KEY);
    return session ? JSON.parse(session) : null;
  } catch (e) {
    return null;
  }
}

// Logout
function logout() {
  localStorage.removeItem(AUTH_SESSION_KEY);
  localStorage.removeItem('ilux_user');
}

// Simulate sending registration email to admin
function sendRegistrationEmail(user) {
  const emailData = {
    to: 'contato@iluxprime.com',
    subject: `New User Registration - ${user.fullName}`,
    body: `
New user registration request:

Full Name: ${user.fullName}
Email: ${user.email}
Phone: ${user.phone}
Country: ${user.country}
Property: ${user.propertyKey || '-'}
Position: ${user.position || '-'}
Username: ${user.username}
Registration Date: ${new Date(user.createdAt).toLocaleString()}

Please review and approve/deny this user access.
User ID: ${user.id}
    `
  };
  
  // Log to console (in production, this would call an email API)
  console.log('ðŸ“§ Registration Email Sent:', emailData);
  
  // Store in a "sent emails" log for demo purposes
  const emailLog = JSON.parse(localStorage.getItem('iluxsys_email_log') || '[]');
  emailLog.push({
    ...emailData,
    sentAt: new Date().toISOString(),
    userId: user.id
  });
  localStorage.setItem('iluxsys_email_log', JSON.stringify(emailLog));
  
  return emailData;
}

// Admin function: Approve user
function approveUser(userId) {
  const users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  
  users[userIndex].status = USER_STATUS.APPROVED;
  users[userIndex].approvedAt = new Date().toISOString();
  
  saveUsers(users);
  
  return { success: true };
}

// Admin function: Approve user with a specific subset of modules and optional property assignment
function approveUserWithModules(userId, modules, propertyKey) {
  const users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  const user = users[userIndex];
  // Normalize modules: distinct and only known module ids
  const allowedModules = Object.values(MODULES);
  const finalModules = Array.isArray(modules) ? modules.filter((m, idx) => allowedModules.includes(m) && modules.indexOf(m) === idx) : [];
  user.modules = finalModules;
  if (typeof propertyKey !== 'undefined') {
    user.propertyKey = propertyKey || null;
  }
  user.status = USER_STATUS.APPROVED;
  user.approvedAt = new Date().toISOString();
  saveUsers(users);
  return { success: true };
}

// Admin function: Deny user
function denyUser(userId) {
  const users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  
  users[userIndex].status = USER_STATUS.DENIED;
  
  saveUsers(users);
  
  return { success: true };
}

// Get pending users (for admin)
function getPendingUsers() {
  const users = getUsers();
  return users.filter(u => u.status === USER_STATUS.PENDING);
}

// Get all users (for admin)
function getAllUsers() {
  return getUsers();
}

// Update user modules (admin only)
function updateUserModules(userId, modules) {
  const users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  
  users[userIndex].modules = modules;
  saveUsers(users);
  
  return { success: true };
}

// Update user property (admin only)
function updateUserProperty(userId, propertyKey) {
  const users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  users[userIndex].propertyKey = propertyKey || null;
  saveUsers(users);
  return { success: true };
}

// Check if user has access to a specific module
function hasModuleAccess(module) {
  const session = getCurrentSession();
  if (!session) return false;
  
  const users = getUsers();
  const user = users.find(u => u.id === session.userId);
  
  if (!user) return false;
  if (user.role === 'admin') return true; // Admin has access to everything
  
  return user.modules && user.modules.includes(module);
}

// Get user's modules
function getUserModules(userId) {
  const users = getUsers();
  const user = users.find(u => u.id === userId);
  
  if (!user) return [];
  if (user.role === 'admin') return Object.values(MODULES);
  
  return user.modules || [];
}

// Get user's property
function getUserProperty(userId) {
  const users = getUsers();
  const user = users.find(u => u.id === userId);
  return user ? (user.propertyKey || null) : null;
}

// Delete user (admin only)
function deleteUser(userId) {
  let users = getUsers();
  const userIndex = users.findIndex(u => u.id === userId);
  
  if (userIndex === -1) {
    return { success: false, error: 'user_not_found' };
  }
  
  // Prevent deleting admin
  if (users[userIndex].role === 'admin') {
    return { success: false, error: 'cannot_delete_admin' };
  }
  
  users = users.filter(u => u.id !== userId);
  saveUsers(users);
  
  return { success: true };
}

// Validate password strength
function validatePassword(password) {
  if (password.length < 8) {
    return { valid: false, error: 'password_too_short' };
  }
  
  const hasNumber = /\d/.test(password);
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  if (!hasNumber || !hasSpecial) {
    return { valid: false, error: 'password_weak' };
  }
  
  return { valid: true };
}

// Initialize auth system on load
if (typeof window !== 'undefined') {
  initializeAuth();
}

// Export functions for use in other scripts
if (typeof window !== 'undefined') {
  window.IluxAuth = {
    registerUser,
    authenticateUser,
    isAuthenticated,
    getCurrentSession,
    logout,
    approveUser,
    approveUserWithModules,
    denyUser,
    getPendingUsers,
    getAllUsers,
    updateUserModules,
    updateUserProperty,
    hasModuleAccess,
    getUserModules,
    getUserProperty,
    deleteUser,
    validatePassword,
    USER_STATUS,
    MODULES,
    MODULE_NAMES
  };
}
